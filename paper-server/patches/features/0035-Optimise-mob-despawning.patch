From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: okx-code <okx@okx.sh>
Date: Mon, 21 Jul 2025 19:52:53 +0100
Subject: [PATCH] Optimise mob despawning


diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 5c62933c0e4f4e02d73ce1575c3f601ba00b9007..470167a4cd1ef943cb219c06defac524844fa634 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -789,6 +789,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             }
 
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
+            generateEligiblePlayersForDespawning();
             this.globalTemptationLookup.reset(); // Paper - optimise temptation lookups - reset global cache prior to next entity tick
             this.entityTickList
                 .forEach(
@@ -2799,6 +2800,28 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
     // Paper end - lag compensation
 
+    // Paper start - optimise despawns
+    @Nullable
+    private io.papermc.paper.util.kdtree.Kd3Tree despawnEligiblePlayers;
+
+    private void generateEligiblePlayersForDespawning() {
+        Vec3[] nodes = new Vec3[players.size()];
+        int i = 0;
+        for (ServerPlayer player : players) {
+            if (net.minecraft.world.entity.EntitySelector.PLAYER_AFFECTS_SPAWNING.test(player)) {
+                nodes[i] = player.position();
+                i++;
+            }
+        }
+        this.despawnEligiblePlayers = new io.papermc.paper.util.kdtree.Kd3Tree(java.util.Arrays.copyOf(nodes, i));
+    }
+
+    @Nullable
+    public io.papermc.paper.util.kdtree.Kd3Tree getDespawnEligiblePlayers() {
+        return despawnEligiblePlayers;
+    }
+    // Paper end - optimise despawns
+
     // Paper start - optimise temptation lookups
     private final io.papermc.paper.entity.temptation.GlobalTemptationLookup globalTemptationLookup = new io.papermc.paper.entity.temptation.GlobalTemptationLookup(); // Paper - Optimise TemptGoal
     public io.papermc.paper.entity.temptation.GlobalTemptationLookup getTemptGoalLookup() {
diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index e0b3cb2b2694768803ed347a1026b881fd624951..74f33fcafc231f620b579e94dcace82dd109008c 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -713,15 +713,16 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         if (this.level().getDifficulty() == Difficulty.PEACEFUL && this.shouldActuallyDespawnInPeaceful()) { //Paper - allow changing despawnInPeaceful
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
-            Entity nearestPlayer = this.level().findNearbyPlayer(this, -1.0, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper - Affects Spawning API
-            if (nearestPlayer != null) {
+            final io.papermc.paper.util.kdtree.Kd3Tree despawnEligiblePlayers = ((ServerLevel) this.level()).getDespawnEligiblePlayers();
+            if (despawnEligiblePlayers != null && !despawnEligiblePlayers.isEmpty()) {
+                final Vec3 nearest = despawnEligiblePlayers.nearest(this.position());
                 // Paper start - Configurable despawn distances
                 final io.papermc.paper.configuration.WorldConfiguration.Entities.Spawning.DespawnRangePair despawnRangePair = this.level().paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory());
                 final io.papermc.paper.configuration.type.DespawnRange.Shape shape = this.level().paperConfig().entities.spawning.despawnRangeShape;
-                final double dy = Math.abs(nearestPlayer.getY() - this.getY());
+                final double dy = Math.abs(nearest.y() - this.getY());
                 final double dySqr = Mth.square(dy);
-                final double dxSqr = Mth.square(nearestPlayer.getX() - this.getX());
-                final double dzSqr = Mth.square(nearestPlayer.getZ() - this.getZ());
+                final double dxSqr = Mth.square(nearest.x() - this.getX());
+                final double dzSqr = Mth.square(nearest.z() - this.getZ());
                 final double distanceSquared = dxSqr + dzSqr + dySqr;
                 // Despawn if hard/soft limit is exceeded
                 if (despawnRangePair.hard().shouldDespawn(shape, dxSqr, dySqr, dzSqr, dy) && this.removeWhenFarAway(distanceSquared)) {
